<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisation d'Arbre D3.js</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
        }
        text {
            font-size: 10px;
        }
        #treeContainer {
            border: 1px solid #ddd;
            height: 800px;
            margin-top: 20px;
        }
        #debugInfo {
            margin-top: 20px;
            padding: 10px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            max-height: 200px;
            overflow: auto;
            font-family: monospace;
        }
        .error {
            color: red;
            font-weight: bold;
        }
        .success {
            color: green;
        }
        button {
            margin-top: 10px;
            padding: 8px 16px;
        }
    </style>
</head>
<body>
    <h1>Visualisation d'Arbre HiÃ©rarchique Multi-Racines</h1>
    
    <div>
        <p>SÃ©lectionnez votre fichier Excel/CSV (format attendu: colonnes "ID", "Name" et "Parent_ID"):</p>
        <input type="file" id="fileInput" accept=".xlsx, .xls, .csv">
        <button id="useExampleData">Utiliser donnÃ©es d'exemple</button>
    </div>
    
    <div id="debugInfo">
        <p>Informations de dÃ©bogage:</p>
        <div id="debugMessages"></div>
    </div>
    
    <div id="treeContainer"></div>

    <script>
        // Fonction pour ajouter des messages de dÃ©bogage
        function debug(message, isError = false) {
            const debugElement = document.getElementById('debugMessages');
            const msgElement = document.createElement('div');
            msgElement.textContent = new Date().toLocaleTimeString() + ': ' + message;
            if (isError) {
                msgElement.className = 'error';
            } else {
                msgElement.className = '';
            }
            debugElement.appendChild(msgElement);
            console.log(message);
        }

        // Dimensions du graphique
        const width = 1600;
        const marginTop = 10;
        const marginRight = 10;
        const marginBottom = 10;
        const marginLeft = 140;
        
        // Hauteur initiale pour accueillir les arbres
        let initialHeight = 3200;

        // CrÃ©er le conteneur SVG
        const svg = d3.select("#treeContainer")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", [-marginLeft, -marginTop, width, initialHeight])
            .attr("style", "max-width: 100%; height: auto; user-select: none;");

        const gLink = svg.append("g")
            .attr("fill", "none")
            .attr("stroke", "#555")
            .attr("stroke-opacity", 0.4)
            .attr("stroke-width", 1.5);

        const gNode = svg.append("g")
            .attr("cursor", "pointer")
            .attr("pointer-events", "all");

        // ParamÃ¨tres pour la disposition des arbres
        const dx = 20;
        const dy = (width - marginRight - marginLeft) / 5; // AjustÃ© pour une meilleure prÃ©sentation

        // DÃ©finir la mise en page de l'arbre et la forme des liens
        const tree = d3.tree().nodeSize([dx, dy]);
        const diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);

        // Couleurs des nÅ“uds pour chaque projet (3 palettes diffÃ©rentes)
        const projectColors = [
            {
                // Projet 1 - SchÃ©ma de couleurs bleu/orange
                open: "#3498db",  // Bleu pour nÅ“uds ouverts
                closed: "#ff7700", // Orange pour nÅ“uds fermÃ©s
                leaf: "#999"      // Gris pour feuilles
            },
            {
                // Projet 2 - SchÃ©ma de couleurs vert/rouge
                open: "#2ecc71",  // Vert pour nÅ“uds ouverts
                closed: "#e74c3c", // Rouge pour nÅ“uds fermÃ©s
                leaf: "#7f8c8d"   // Gris foncÃ© pour feuilles
            },
            {
                // Projet 3 - SchÃ©ma de couleurs violet/jaune
                open: "#9b59b6",  // Violet pour nÅ“uds ouverts
                closed: "#f1c40f", // Jaune pour nÅ“uds fermÃ©s
                leaf: "#95a5a6"   // Gris moyen pour feuilles
            }
        ];

        // Fonction pour mettre Ã  jour l'arbre
        function update(event, source) {
            const duration = event?.altKey ? 2500 : 250;
            
            // Calculer les positions pour chaque arbre
            let allNodes = [];
            let allLinks = [];
            let minX = Infinity;
            let maxX = -Infinity;
            
            // Traiter chaque racine sÃ©parÃ©ment
            let verticalOffset = 0; // Commencer Ã  0 pour la premiÃ¨re racine

            // Premier passage pour calculer la taille de chaque arbre
            const treeSizes = [];
            roots.forEach((root, index) => {
                // Appliquer la disposition d'arbre
                tree(root);
                
                // Calculer min et max pour cet arbre
                let treeMinX = Infinity;
                let treeMaxX = -Infinity;
                
                root.each(node => {
                    if (node.x < treeMinX) treeMinX = node.x;
                    if (node.x > treeMaxX) treeMaxX = node.x;
                });
                
                // Stocker la taille de l'arbre et rÃ©initialiser les positions
                treeSizes.push({
                    height: treeMaxX - treeMinX + 40, // Ajouter un espace tampon
                    minX: treeMinX,
                    maxX: treeMaxX
                });
            });
            
            // DeuxiÃ¨me passage pour positionner les arbres avec des espacements dynamiques
            roots.forEach((root, index) => {
                // Calculer le dÃ©calage vertical en fonction des arbres prÃ©cÃ©dents
                if (index > 0) {
                    // Somme des hauteurs des arbres prÃ©cÃ©dents + espacement
                    verticalOffset += treeSizes[index - 1].height;
                }
                
                // Appliquer la disposition d'arbre Ã  nouveau
                tree(root);
                
                // DÃ©caler les positions verticales pour sÃ©parer les arbres
                root.each(node => {
                    node.originalX = node.x;
                    node.x += verticalOffset;
                    node.treeIndex = index; // Ajouter l'index de l'arbre Ã  chaque nÅ“ud
                    
                    // Mettre Ã  jour les limites pour le viewBox
                    if (node.x < minX) minX = node.x;
                    if (node.x > maxX) maxX = node.x;
                });
                
                // Collecter tous les nÅ“uds et liens pour le rendu
                allNodes = allNodes.concat(root.descendants());
                allLinks = allLinks.concat(root.links());
            });
            
            // Calculer la hauteur totale nÃ©cessaire
            const height = maxX - minX + marginTop + marginBottom + 150;
            
            // Mettre Ã  jour la hauteur du SVG
            svg.transition()
                .duration(duration)
                .attr("height", height)
                .attr("viewBox", [-marginLeft, minX - marginTop, width, height]);
            
            // Mettre Ã  jour les nÅ“uds
            const node = gNode.selectAll("g")
                .data(allNodes, d => d.id || (d.id = Math.random().toString(36).substr(2, 9)));
            
            // Entrer de nouveaux nÅ“uds
            const nodeEnter = node.enter().append("g")
                .attr("transform", d => {
                    const sourceX = source ? source.x0 : (d.parent ? d.parent.x0 : 0);
                    const sourceY = source ? source.y0 : (d.parent ? d.parent.y0 : 0);
                    return `translate(${sourceY},${sourceX})`;
                })
                .attr("fill-opacity", 0)
                .attr("stroke-opacity", 0)
                .on("click", (event, d) => {
                    d.children = d.children ? null : d._children;
                    update(event, d);
                });
            
            // Fonction pour dÃ©terminer la couleur des nÅ“uds selon le projet
            const getNodeColor = (d) => {
                // RÃ©cupÃ©rer la palette de couleurs du projet
                const colors = projectColors[d.treeIndex % projectColors.length];
                
                if (d._children) {
                    return colors.closed; // Couleur pour nÅ“uds fermÃ©s
                } else if (d.children && d.children.length > 0) {
                    return colors.open; // Couleur pour nÅ“uds ouverts
                } else {
                    return colors.leaf; // Couleur pour feuilles
                }
            };
            
            nodeEnter.append("circle")
                .attr("r", 3)
                .attr("fill", getNodeColor)
                .attr("stroke-width", 10);
            
            nodeEnter.append("text")
                .attr("dy", "0.31em")
                .attr("x", d => d._children ? -6 : 6)
                .attr("text-anchor", d => d._children ? "end" : "start")
                .text(d => d.data.name)
                .attr("stroke-linejoin", "round")
                .attr("stroke-width", 2)
                .attr("stroke", "white")
                .attr("paint-order", "stroke");
            
            // Transitionner les nÅ“uds vers leur nouvelle position
            const nodeUpdate = node.merge(nodeEnter).transition(duration)
                .attr("transform", d => `translate(${d.y},${d.x})`)
                .attr("fill-opacity", 1)
                .attr("stroke-opacity", 1);
            
            nodeUpdate.select("circle")
                .attr("fill", getNodeColor);
            
            // Transitionner les nÅ“uds sortants
            const nodeExit = node.exit().transition(duration).remove()
                .attr("transform", d => {
                    const targetX = d.parent ? d.parent.x : d.x;
                    const targetY = d.parent ? d.parent.y : d.y;
                    return `translate(${targetY},${targetX})`;
                })
                .attr("fill-opacity", 0)
                .attr("stroke-opacity", 0);
            
            // Mettre Ã  jour les liens
            const link = gLink.selectAll("path")
                .data(allLinks, d => d.target.id);
            
            // Couleur des liens basÃ©e sur le projet
            const getLinkColor = (d) => {
                const treeIndex = d.source.treeIndex;
                const colors = projectColors[treeIndex % projectColors.length];
                return colors ? colors.open : "#555";
            };
            
            // Entrer de nouveaux liens
            const linkEnter = link.enter().append("path")
                .attr("d", d => {
                    const o = { 
                        x: source ? source.x0 : (d.source.x0 || d.source.x),
                        y: source ? source.y0 : (d.source.y0 || d.source.y)
                    };
                    return diagonal({ source: o, target: o });
                })
                .attr("stroke", getLinkColor);
            
            // Transitionner les liens vers leur nouvelle position
            link.merge(linkEnter).transition(duration)
                .attr("d", diagonal)
                .attr("stroke", getLinkColor);
            
            // Transitionner les liens sortants
            link.exit().transition(duration).remove()
                .attr("d", d => {
                    const o = { 
                        x: d.source.x || d.source.x0,
                        y: d.source.y || d.source.y0
                    };
                    return diagonal({ source: o, target: o });
                });
            
            // Stocker les positions pour la prochaine transition
            allNodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            // Marquer la derniÃ¨re mise Ã  jour comme rÃ©ussie
            if (document.getElementById('debugMessages').lastElementChild) {
                document.getElementById('debugMessages').lastElementChild.className = 'success';
            }
        }

        // Fonction pour convertir les donnÃ©es tabulaires en structure hiÃ©rarchique
        function buildTreeDataFromFlatData(flatData) {
            debug("Construction de la structure d'arbre Ã  partir des donnÃ©es plates...");
            
            // CrÃ©er une table de hachage pour accÃ¨s rapide
            const nodeMap = {};
            flatData.forEach(item => {
                nodeMap[item.id] = { ...item, children: [] };
            });
            
            // Identifier les racines et construire les arbres
            const rootNodes = [];
            const childrenNodes = new Set();
            
            flatData.forEach(item => {
                // Si un nÅ“ud a un parent valide
                if (item.parentId !== 0 && nodeMap[item.parentId]) {
                    const parent = nodeMap[item.parentId];
                    if (!parent.children) parent.children = [];
                    parent.children.push(nodeMap[item.id]);
                    childrenNodes.add(item.id);
                }
            });
            
            // Les nÅ“uds qui ne sont pas des enfants sont des racines potentielles
            flatData.forEach(item => {
                if (!childrenNodes.has(item.id) && item.parentId === 0) {
                    rootNodes.push(nodeMap[item.id]);
                }
            });
            
            debug(`Identification de ${rootNodes.length} nÅ“uds racines`);
            
            return rootNodes;
        }

        // Variable globale pour stocker les racines de l'arbre
        let roots = [];

        // Fonction pour traiter les donnÃ©es chargÃ©es
        function processLoadedData(data) {
            try {
                // Nettoyer le graphique prÃ©cÃ©dent
                gLink.selectAll("path").remove();
                gNode.selectAll("g").remove();
                
                // Construire les arbres
                const treeData = buildTreeDataFromFlatData(data);
                
                // S'il n'y a pas de racines, afficher un message d'erreur
                if (treeData.length === 0) {
                    debug("Aucun nÅ“ud racine trouvÃ© dans les donnÃ©es. VÃ©rifiez que les identifiants et relations parent-enfant sont corrects.", true);
                    return;
                }
                
                debug(`${treeData.length} arbres distincts crÃ©Ã©s Ã  partir des donnÃ©es`);
                
                // CrÃ©er une hiÃ©rarchie pour chaque racine
                roots = treeData.map((d, i) => {
                    const root = d3.hierarchy(d);
                    root.x0 = 0;
                    root.y0 = 0;
                    root.treeIndex = i;
                    return root;
                });
                
                // PrÃ©parer les arbres pour l'affichage initial
                // MODIFICATION ICI: tous les niveaux sont maintenant fermÃ©s
                roots.forEach((root, index) => {
                    root.descendants().forEach((d, i) => {
                        d.id = `tree-${index}-node-${i}`;
                        d._children = d.children;
                        d.treeIndex = index;
                        
                        // Modifier cette partie: tous les nÅ“uds sont fermÃ©s sauf les racines
                        if (d.depth > 0) {
                            d.children = null;
                        }
                    });
                });
                
                // Mettre Ã  jour l'affichage
                update(null, null);
                
                debug("Arbres affichÃ©s avec succÃ¨s", false);
                
            } catch (error) {
                debug(`Erreur lors du traitement des donnÃ©es: ${error.message}`, true);
                console.error(error);
            }
        }

        // GÃ©rer l'upload du fichier
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('useExampleData').addEventListener('click', useExampleData);

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                debug("Aucun fichier sÃ©lectionnÃ©", true);
                return;
            }

            debug(`Fichier sÃ©lectionnÃ©: ${file.name}`);
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    let data;
                    
                    if (file.name.endsWith('.csv')) {
                        // Traiter le CSV avec le bon encodage
                        const csvData = e.target.result;
                        debug("Analyse du fichier CSV...");
                        
                        // DÃ©tecter le sÃ©parateur (virgule ou point-virgule)
                        const firstLine = csvData.split('\n')[0];
                        const delimiter = firstLine.includes(';') ? ';' : ',';
                        debug(`SÃ©parateur CSV dÃ©tectÃ©: "${delimiter}"`);
                        
                        // DÃ©tecter la prÃ©sence du BOM (Byte Order Mark)
                        let cleanData = csvData;
                        if (csvData.charCodeAt(0) === 0xFEFF) {
                            debug("BOM UTF-8 dÃ©tectÃ© et retirÃ©");
                            cleanData = csvData.slice(1);
                        }
                        
                        // Analyser avec le bon sÃ©parateur et en tenant compte de l'encoding
                        try {
                            data = d3.dsvFormat(delimiter).parse(cleanData);
                            debug("DonnÃ©es CSV analysÃ©es avec succÃ¨s");
                        } catch (csvError) {
                            debug(`Erreur lors de l'analyse CSV: ${csvError.message}`, true);
                            throw csvError;
                        }
                    } else {
                        // Traiter l'Excel avec support des caractÃ¨res spÃ©ciaux
                        const arrayBuffer = e.target.result;
                        debug("Analyse du fichier Excel...");
                        
                        // Configuration d'encodage pour XLSX
                        const workbook = XLSX.read(arrayBuffer, {
                            type: 'array',
                            raw: true, // Conserver les types de donnÃ©es
                            cellText: true // AmÃ©liore la prise en charge des caractÃ¨res spÃ©ciaux
                        });
                        
                        // Afficher les noms des feuilles disponibles
                        debug(`Feuilles disponibles: ${workbook.SheetNames.join(', ')}`);
                        
                        // Prendre la premiÃ¨re feuille
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];
                        
                        // Convertir en JSON avec options d'encodage
                        data = XLSX.utils.sheet_to_json(worksheet, {
                            raw: false, // Convertir les cellules en chaÃ®nes pour Ã©viter les problÃ¨mes d'encodage
                            defval: "" // Valeur par dÃ©faut pour les cellules vides
                        });
                    }
                    
                    if (data && data.length > 0) {
                        debug(`${data.length} lignes chargÃ©es`);
                        debug(`Colonnes dÃ©tectÃ©es: ${Object.keys(data[0]).join(', ')}`);
                        
                        // Afficher les premiÃ¨res lignes pour dÃ©bogage avec encodage correct
                        debug(`PremiÃ¨re ligne: ${JSON.stringify(data[0], null, 2)}`);
                        
                        // PrÃ©parer les donnÃ©es dans le format attendu
                        prepareDataFromFile(data);
                    } else {
                        debug("Aucune donnÃ©e trouvÃ©e dans le fichier", true);
                    }
                } catch (error) {
                    debug(`Erreur lors du traitement du fichier: ${error.message}`, true);
                    console.error(error);
                }
            };
            
            reader.onerror = function() {
                debug("Erreur lors de la lecture du fichier", true);
            };
            
            if (file.name.endsWith('.csv')) {
                // Lire le fichier en tant que texte avec UTF-8
                reader.readAsText(file, "UTF-8");
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        function prepareDataFromFile(fileData) {
            try {
                debug("PrÃ©paration des donnÃ©es pour visualisation...");
                
                // DÃ©terminer les noms des colonnes (gÃ©rer diffÃ©rentes variantes possibles)
                const sample = fileData[0];
                
                // Fonctions pour vÃ©rifier les noms de colonnes (plus robuste)
                function isIdColumn(key) {
                    return /^id$/i.test(key) || /^ID$/i.test(key);
                }
                
                function isNameColumn(key) {
                    return /^name$/i.test(key) || /^Name$/i.test(key) || /^nom$/i.test(key) || /^NOM$/i.test(key);
                }
                
                function isParentIdColumn(key) {
                    return /^parent[\s_-]?id$/i.test(key) || /^Parent[\s_-]?ID$/i.test(key) || 
                           /^parent[\s_-]?id$/i.test(key) || /^Parent[\s_-]?Id$/i.test(key);
                }
                
                let idColumn = Object.keys(sample).find(isIdColumn);
                let nameColumn = Object.keys(sample).find(isNameColumn);
                let parentIdColumn = Object.keys(sample).find(isParentIdColumn);
                
                // Si les colonnes ne sont pas trouvÃ©es, essayer avec des variations (pour gÃ©rer les BOM ou caractÃ¨res invisibles)
                if (!idColumn) {
                    idColumn = Object.keys(sample).find(key => key.toLowerCase().includes('id') && !key.toLowerCase().includes('parent'));
                }
                if (!nameColumn) {
                    nameColumn = Object.keys(sample).find(key => key.toLowerCase().includes('name') || key.toLowerCase().includes('nom'));
                }
                if (!parentIdColumn) {
                    parentIdColumn = Object.keys(sample).find(key => key.toLowerCase().includes('parent'));
                }
                
                if (!idColumn || !nameColumn || !parentIdColumn) {
                    debug(`Colonnes requises non trouvÃ©es. Utilisez ID, Name et Parent_ID. Colonnes actuelles: ${Object.keys(sample).join(', ')}`, true);
                    return;
                }
                
                debug(`Utilisation des colonnes: ID=${idColumn}, Name=${nameColumn}, Parent_ID=${parentIdColumn}`);
                
                // Nettoyer les donnÃ©es avec support pour caractÃ¨res spÃ©ciaux
                const cleanData = fileData.map(row => {
                    // Conversion explicite pour s'assurer que les valeurs sont traitÃ©es correctement
                    const id = typeof row[idColumn] === 'string' ? parseInt(row[idColumn], 10) : +row[idColumn];
                    // PrÃ©server les caractÃ¨res spÃ©ciaux en utilisant une chaÃ®ne de caractÃ¨res directe
                    const name = row[nameColumn] ? String(row[nameColumn]).trim() : "";
                    // GÃ©rer la valeur parent (convertir en 0 si null, undefined ou NaN)
                    let parentId = typeof row[parentIdColumn] === 'string' ? 
                        parseInt(row[parentIdColumn], 10) : +row[parentIdColumn];
                    parentId = isNaN(parentId) ? 0 : parentId;
                    
                    return { id, name, parentId };
                });
                
                // Afficher quelques exemples pour dÃ©boguer l'encodage
                if (cleanData.length > 0) {
                    debug(`Exemple de donnÃ©es prÃ©parÃ©es (premiÃ¨re ligne): ${JSON.stringify(cleanData[0])}`);
                }
                
                // Traiter et afficher les donnÃ©es
                processLoadedData(cleanData);
                
            } catch (error) {
                debug(`Erreur lors de la prÃ©paration des donnÃ©es: ${error.message}`, true);
                console.error(error);
            }
        }

        function useExampleData() {
            debug("Chargement des donnÃ©es d'exemple...");
            
            const exampleData = [
                // Premier arbre avec caractÃ¨res spÃ©ciaux et emojis
                { ID: 1, Name: "Vitrage BoÃ®te T2 ğŸ¢", Parent_ID: 0 },
                { ID: 2, Name: "MatÃ©riels & Ã‰quipements", Parent_ID: 1 },
                { ID: 3, Name: "Grue sur remorque (KlÃ¤ss)", Parent_ID: 2 },
                { ID: 4, Name: "Palonnier Ã  ventouse âœ¨", Parent_ID: 2 },
                { ID: 5, Name: "Plaques de rÃ©partition ğŸ”§", Parent_ID: 2 },
                { ID: 6, Name: "Vitrages (RÃ‰BÃˆR)", Parent_ID: 2 },
                { ID: 7, Name: "Nacelle araignÃ©e 27m ğŸ•¸ï¸", Parent_ID: 2 },
                { ID: 8, Name: "Sous-Ã©lÃ©ment 1-A", Parent_ID: 3 },
                { ID: 9, Name: "Sous-Ã©lÃ©ment 1-B", Parent_ID: 3 },
                { ID: 10, Name: "Chien ğŸ•", Parent_ID: 4 },
                { ID: 11, Name: "Chat ğŸˆ", Parent_ID: 4 },
                { ID: 12, Name: "Sous-Ã©lÃ©ment 2-A", Parent_ID: 5 },
                { ID: 13, Name: "Sous-Ã©lÃ©ment 2-B", Parent_ID: 5 },
                { ID: 14, Name: "Sous-Ã©lÃ©ment 3-A", Parent_ID: 6 },
                { ID: 15, Name: "Sous-Ã©lÃ©ment 4-A", Parent_ID: 7 },
                { ID: 16, Name: "Sous-Ã©lÃ©ment 4-B", Parent_ID: 7 },
                { ID: 17, Name: "Sous-Ã©lÃ©ment 4-C", Parent_ID: 7 },
                { ID: 18, Name: "Alain DÃ©licÃ©", Parent_ID: 1 },
                { ID: 19, Name: "PremiÃ¨re Ã©tape â¡ï¸", Parent_ID: 18 },
                { ID: 20, Name: "DeuxiÃ¨me Ã©tape ğŸ”„", Parent_ID: 18 },
                { ID: 21, Name: "Enfant 2", Parent_ID: 1 },
                { ID: 22, Name: "Petit-enfant 1 ğŸ‘¶", Parent_ID: 21 },
                { ID: 23, Name: "Petit-enfant 2 ğŸ‘¶", Parent_ID: 21 },
                { ID: 24, Name: "Alain2", Parent_ID: 1 },
                { ID: 25, Name: "Sous-Ã©lÃ©ment 2-A", Parent_ID: 24 },
                { ID: 26, Name: "Sous-Ã©lÃ©ment 2-B", Parent_ID: 24 },
                
                // DeuxiÃ¨me arbre avec caractÃ¨res spÃ©ciaux
                { ID: 100, Name: "DeuxiÃ¨me Projet ğŸ“Š", Parent_ID: 0 },
                { ID: 101, Name: "Ã‰quipement SpÃ©cial", Parent_ID: 100 },
                { ID: 102, Name: "Personnel", Parent_ID: 100 },
                { ID: 103, Name: "MatÃ©riel A", Parent_ID: 101 },
                { ID: 104, Name: "MatÃ©riel B", Parent_ID: 101 },
                { ID: 105, Name: "Ã‰quipe 1 ğŸ‘©â€ğŸ’¼ğŸ‘¨â€ğŸ’¼", Parent_ID: 102 },
                { ID: 106, Name: "Ã‰quipe 2 ğŸ‘©â€ğŸ’»ğŸ‘¨â€ğŸ’»", Parent_ID: 102 },
                
                // TroisiÃ¨me arbre avec caractÃ¨res spÃ©ciaux
                { ID: 200, Name: "TroisiÃ¨me Projet ğŸ¯", Parent_ID: 0 },
                { ID: 201, Name: "Finances ğŸ’°", Parent_ID: 200 },
                { ID: 202, Name: "Planning ğŸ“…", Parent_ID: 200 },
                { ID: 203, Name: "Partenaires ğŸ¤", Parent_ID: 200 },
                { ID: 204, Name: "Budget â‚¬$Â£", Parent_ID: 201 },
                { ID: 205, Name: "Investissements ğŸ“ˆ", Parent_ID: 201 },
                { ID: 206, Name: "Phase 1 â—€ï¸", Parent_ID: 202 },
                { ID: 207, Name: "Phase 2 âºï¸", Parent_ID: 202 },
                { ID: 208, Name: "Phase 3 â–¶ï¸", Parent_ID: 202 },
                { ID: 209, Name: "Fournisseurs", Parent_ID: 203 },
                { ID: 210, Name: "Clients", Parent_ID: 203 }
            ];
            
            prepareDataFromFile(exampleData);
        }

        // Initialiser avec un message
        debug("Application chargÃ©e. Veuillez sÃ©lectionner un fichier Excel/CSV ou utiliser les donnÃ©es d'exemple.");
    </script>
</body>
</html>