<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisation d'Arbre D3.js</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
        }
        text {
            font-size: 10px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #treeContainer {
            border: 1px solid #ddd;
            height: 800px;
            margin-top: 20px;
        }
        #debugInfo {
            margin-top: 20px;
            padding: 10px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            max-height: 200px;
            overflow: auto;
            font-family: monospace;
        }
        .error {
            color: red;
            font-weight: bold;
        }
        .success {
            color: green;
        }
        button {
            margin-top: 10px;
            padding: 8px 16px;
        }
    </style>
</head>
<body>
    <h1>Visualisation d'Arbre Hi√©rarchique Multi-Racines</h1>
    
    <div>
        <p>S√©lectionnez votre fichier Excel/CSV (format attendu: colonnes "ID", "Name" et "Parent_ID"):</p>
        <input type="file" id="fileInput" accept=".xlsx, .xls, .csv">
        <button id="useExampleData">Utiliser donn√©es d'exemple</button>
    </div>
    
    <div id="debugInfo">
        <p>Informations de d√©bogage:</p>
        <div id="debugMessages"></div>
    </div>
    
    <div id="treeContainer"></div>

    <script>
        // Fonction pour ajouter des messages de d√©bogage
        function debug(message, isError = false) {
            const debugElement = document.getElementById('debugMessages');
            const msgElement = document.createElement('div');
            msgElement.textContent = new Date().toLocaleTimeString() + ': ' + message;
            if (isError) {
                msgElement.className = 'error';
            } else {
                msgElement.className = '';
            }
            debugElement.appendChild(msgElement);
            console.log(message);
        }

        // Dimensions du graphique
        const width = 1600;
        const marginTop = 10;
        const marginRight = 10;
        const marginBottom = 10;
        const marginLeft = 180;
        
        // Hauteur initiale pour accueillir les arbres
        let initialHeight = 3200;

        // Cr√©er le conteneur SVG
        const svg = d3.select("#treeContainer")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", [-marginLeft, -marginTop, width, initialHeight])
            .attr("style", "max-width: 100%; height: auto; user-select: none;");

        const gLink = svg.append("g")
            .attr("fill", "none")
            .attr("stroke", "#555")
            .attr("stroke-opacity", 0.4)
            .attr("stroke-width", 1.5);

        const gNode = svg.append("g")
            .attr("cursor", "pointer")
            .attr("pointer-events", "all");

        // Param√®tres pour la disposition des arbres
        const dx = 20;
        const dy = (width - marginRight - marginLeft) / 5; // Ajust√© pour une meilleure pr√©sentation

        // D√©finir la mise en page de l'arbre et la forme des liens
        const tree = d3.tree().nodeSize([dx, dy]);
        const diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);

        // Couleurs des n≈ìuds pour chaque projet (3 palettes diff√©rentes)
        const projectColors = [
            {
                // Projet 1 - Sch√©ma de couleurs bleu/orange
                open: "#3498db",  // Bleu pour n≈ìuds ouverts
                closed: "#ff7700", // Orange pour n≈ìuds ferm√©s
                leaf: "#999"      // Gris pour feuilles
            },
            {
                // Projet 2 - Sch√©ma de couleurs vert/rouge
                open: "#2ecc71",  // Vert pour n≈ìuds ouverts
                closed: "#e74c3c", // Rouge pour n≈ìuds ferm√©s
                leaf: "#7f8c8d"   // Gris fonc√© pour feuilles
            },
            {
                // Projet 3 - Sch√©ma de couleurs violet/jaune
                open: "#9b59b6",  // Violet pour n≈ìuds ouverts
                closed: "#f1c40f", // Jaune pour n≈ìuds ferm√©s
                leaf: "#95a5a6"   // Gris moyen pour feuilles
            }
        ];

        // Fonction pour mettre √† jour l'arbre
        function update(event, source) {
            const duration = event?.altKey ? 2500 : 250;
            
            // Calculer les positions pour chaque arbre
            let allNodes = [];
            let allLinks = [];
            let minX = Infinity;
            let maxX = -Infinity;
            
            // Traiter chaque racine s√©par√©ment
            let verticalOffset = 0; // Commencer √† 0 pour la premi√®re racine

            // Premier passage pour calculer la taille de chaque arbre
            const treeSizes = [];
            roots.forEach((root, index) => {
                // Appliquer la disposition d'arbre
                tree(root);
                
                // Calculer min et max pour cet arbre
                let treeMinX = Infinity;
                let treeMaxX = -Infinity;
                
                root.each(node => {
                    if (node.x < treeMinX) treeMinX = node.x;
                    if (node.x > treeMaxX) treeMaxX = node.x;
                });
                
                // Stocker la taille de l'arbre et r√©initialiser les positions
                treeSizes.push({
                    height: treeMaxX - treeMinX + 40, // Ajouter un espace tampon
                    minX: treeMinX,
                    maxX: treeMaxX
                });
            });
            
            // Deuxi√®me passage pour positionner les arbres avec des espacements dynamiques
            roots.forEach((root, index) => {
                // Calculer le d√©calage vertical en fonction des arbres pr√©c√©dents
                if (index > 0) {
                    // Somme des hauteurs des arbres pr√©c√©dents + espacement
                    verticalOffset += treeSizes[index - 1].height;
                }
                
                // Appliquer la disposition d'arbre √† nouveau
                tree(root);
                
                // D√©caler les positions verticales pour s√©parer les arbres
                root.each(node => {
                    node.originalX = node.x;
                    node.x += verticalOffset;
                    node.treeIndex = index; // Ajouter l'index de l'arbre √† chaque n≈ìud
                    
                    // Mettre √† jour les limites pour le viewBox
                    if (node.x < minX) minX = node.x;
                    if (node.x > maxX) maxX = node.x;
                });
                
                // Collecter tous les n≈ìuds et liens pour le rendu
                allNodes = allNodes.concat(root.descendants());
                allLinks = allLinks.concat(root.links());
            });
            
            // Calculer la hauteur totale n√©cessaire
            const height = maxX - minX + marginTop + marginBottom + 150;
            
            // Mettre √† jour la hauteur du SVG
            svg.transition()
                .duration(duration)
                .attr("height", height)
                .attr("viewBox", [-marginLeft, minX - marginTop, width, height]);
            
            // Mettre √† jour les n≈ìuds
            const node = gNode.selectAll("g")
                .data(allNodes, d => d.id || (d.id = Math.random().toString(36).substr(2, 9)));
            
            // Entrer de nouveaux n≈ìuds
            const nodeEnter = node.enter().append("g")
                .attr("transform", d => {
                    const sourceX = source ? source.x0 : (d.parent ? d.parent.x0 : 0);
                    const sourceY = source ? source.y0 : (d.parent ? d.parent.y0 : 0);
                    return `translate(${sourceY},${sourceX})`;
                })
                .attr("fill-opacity", 0)
                .attr("stroke-opacity", 0)
                .on("click", (event, d) => {
                    d.children = d.children ? null : d._children;
                    update(event, d);
                });
            
            // Fonction pour d√©terminer la couleur des n≈ìuds selon le projet
            const getNodeColor = (d) => {
                // R√©cup√©rer la palette de couleurs du projet
                const colors = projectColors[d.treeIndex % projectColors.length];
                
                if (d._children) {
                    return colors.closed; // Couleur pour n≈ìuds ferm√©s
                } else if (d.children && d.children.length > 0) {
                    return colors.open; // Couleur pour n≈ìuds ouverts
                } else {
                    return colors.leaf; // Couleur pour feuilles
                }
            };
            
            nodeEnter.append("circle")
                .attr("r", 3)
                .attr("fill", getNodeColor)
                .attr("stroke-width", 10);
            
            // Modification pour am√©liorer le rendu du texte pour les emojis et accents
            nodeEnter.append("text")
                .attr("dy", "0.31em")
                .attr("x", d => d._children ? -6 : 6)
                .attr("text-anchor", d => d._children ? "end" : "start")
                .text(d => d.data.name)
                .attr("stroke-linejoin", "round")
                .attr("stroke-width", 2)
                .attr("stroke", "white")
                .attr("paint-order", "stroke")
                .style("font-family", "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif"); // Ajout d'une police compatible avec les emojis
            
            // Transitionner les n≈ìuds vers leur nouvelle position
            const nodeUpdate = node.merge(nodeEnter).transition(duration)
                .attr("transform", d => `translate(${d.y},${d.x})`)
                .attr("fill-opacity", 1)
                .attr("stroke-opacity", 1);
            
            nodeUpdate.select("circle")
                .attr("fill", getNodeColor);
            
            // Transitionner les n≈ìuds sortants
            const nodeExit = node.exit().transition(duration).remove()
                .attr("transform", d => {
                    const targetX = d.parent ? d.parent.x : d.x;
                    const targetY = d.parent ? d.parent.y : d.y;
                    return `translate(${targetY},${targetX})`;
                })
                .attr("fill-opacity", 0)
                .attr("stroke-opacity", 0);
            
            // Mettre √† jour les liens
            const link = gLink.selectAll("path")
                .data(allLinks, d => d.target.id);
            
            // Couleur des liens bas√©e sur le projet
            const getLinkColor = (d) => {
                const treeIndex = d.source.treeIndex;
                const colors = projectColors[treeIndex % projectColors.length];
                return colors ? colors.open : "#555";
            };
            
            // Entrer de nouveaux liens
            const linkEnter = link.enter().append("path")
                .attr("d", d => {
                    const o = { 
                        x: source ? source.x0 : (d.source.x0 || d.source.x),
                        y: source ? source.y0 : (d.source.y0 || d.source.y)
                    };
                    return diagonal({ source: o, target: o });
                })
                .attr("stroke", getLinkColor);
            
            // Transitionner les liens vers leur nouvelle position
            link.merge(linkEnter).transition(duration)
                .attr("d", diagonal)
                .attr("stroke", getLinkColor);
            
            // Transitionner les liens sortants
            link.exit().transition(duration).remove()
                .attr("d", d => {
                    const o = { 
                        x: d.source.x || d.source.x0,
                        y: d.source.y || d.source.y0
                    };
                    return diagonal({ source: o, target: o });
                });
            
            // Stocker les positions pour la prochaine transition
            allNodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            // Marquer la derni√®re mise √† jour comme r√©ussie
            if (document.getElementById('debugMessages').lastElementChild) {
                document.getElementById('debugMessages').lastElementChild.className = 'success';
            }
        }

        // Fonction pour convertir les donn√©es tabulaires en structure hi√©rarchique
        function buildTreeDataFromFlatData(flatData) {
            debug("Construction de la structure d'arbre √† partir des donn√©es plates...");
            
            // Cr√©er une table de hachage pour acc√®s rapide
            const nodeMap = {};
            flatData.forEach(item => {
                nodeMap[item.id] = { ...item, children: [] };
            });
            
            // Identifier les racines et construire les arbres
            const rootNodes = [];
            const childrenNodes = new Set();
            
            flatData.forEach(item => {
                // Si un n≈ìud a un parent valide
                if (item.parentId !== 0 && nodeMap[item.parentId]) {
                    const parent = nodeMap[item.parentId];
                    if (!parent.children) parent.children = [];
                    parent.children.push(nodeMap[item.id]);
                    childrenNodes.add(item.id);
                }
            });
            
            // Les n≈ìuds qui ne sont pas des enfants sont des racines potentielles
            flatData.forEach(item => {
                if (!childrenNodes.has(item.id) && item.parentId === 0) {
                    rootNodes.push(nodeMap[item.id]);
                }
            });
            
            debug(`Identification de ${rootNodes.length} n≈ìuds racines`);
            
            return rootNodes;
        }

        // Variable globale pour stocker les racines de l'arbre
        let roots = [];

        // Fonction pour traiter les donn√©es charg√©es
        function processLoadedData(data) {
            try {
                // Nettoyer le graphique pr√©c√©dent
                gLink.selectAll("path").remove();
                gNode.selectAll("g").remove();
                
                // Construire les arbres
                const treeData = buildTreeDataFromFlatData(data);
                
                // S'il n'y a pas de racines, afficher un message d'erreur
                if (treeData.length === 0) {
                    debug("Aucun n≈ìud racine trouv√© dans les donn√©es. V√©rifiez que les identifiants et relations parent-enfant sont corrects.", true);
                    return;
                }
                
                debug(`${treeData.length} arbres distincts cr√©√©s √† partir des donn√©es`);
                
                // Cr√©er une hi√©rarchie pour chaque racine
                roots = treeData.map((d, i) => {
                    const root = d3.hierarchy(d);
                    root.x0 = 0;
                    root.y0 = 0;
                    root.treeIndex = i;
                    return root;
                });
                
                // Pr√©parer les arbres pour l'affichage initial
                // MODIFICATION ICI: tous les niveaux sont maintenant ferm√©s
                roots.forEach((root, index) => {
                    root.descendants().forEach((d, i) => {
                        d.id = `tree-${index}-node-${i}`;
                        d._children = d.children;
                        d.treeIndex = index;
                        
                        // Modifier cette partie: tous les n≈ìuds sont ferm√©s sauf les racines
                        if (d.depth > 0) {
                            d.children = null;
                        }
                    });
                });
                
                // Mettre √† jour l'affichage
                update(null, null);
                
                debug("Arbres affich√©s avec succ√®s", false);
                
            } catch (error) {
                debug(`Erreur lors du traitement des donn√©es: ${error.message}`, true);
                console.error(error);
            }
        }

        // G√©rer l'upload du fichier
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('useExampleData').addEventListener('click', useExampleData);

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                debug("Aucun fichier s√©lectionn√©", true);
                return;
            }

            debug(`Fichier s√©lectionn√©: ${file.name}`);
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    let data;
                    
                    if (file.name.endsWith('.csv')) {
                        // Traiter le CSV avec la gestion am√©lior√©e des encodages
                        const csvData = e.target.result;
                        debug("Analyse du fichier CSV...");
                        
                        // D√©tecter le s√©parateur (virgule ou point-virgule)
                        const firstLine = csvData.split('\n')[0];
                        const delimiter = firstLine.includes(';') ? ';' : ',';
                        debug(`S√©parateur CSV d√©tect√©: "${delimiter}"`);
                        
                        // D√©tecter et traiter le BOM (Byte Order Mark)
                        let cleanData = csvData;
                        // V√©rifier diff√©rents types de BOM
                        if (csvData.charCodeAt(0) === 0xFEFF) {
                            debug("BOM UTF-8 d√©tect√© et retir√©");
                            cleanData = csvData.slice(1);
                        } else if (csvData.charCodeAt(0) === 0xFFFE) {
                            debug("BOM UTF-16 (LE) d√©tect√© et retir√©");
                            cleanData = csvData.slice(2);
                        } else if (csvData.charCodeAt(0) === 0xFFFE && csvData.charCodeAt(1) === 0x0000) {
                            debug("BOM UTF-32 (LE) d√©tect√© et retir√©");
                            cleanData = csvData.slice(4);
                        }
                        
                        // Analyser avec le bon s√©parateur
                        try {
                            data = d3.dsvFormat(delimiter).parse(cleanData);
                            debug("Donn√©es CSV analys√©es avec succ√®s");
                        } catch (csvError) {
                            debug(`Erreur lors de l'analyse CSV: ${csvError.message}`, true);
                            throw csvError;
                        }
                    } else {
                        // Traiter l'Excel avec support renforc√© des caract√®res sp√©ciaux
                        const arrayBuffer = e.target.result;
                        debug("Analyse du fichier Excel...");
                        
                        // Configuration optimis√©e pour XLSX
                        const workbook = XLSX.read(arrayBuffer, {
                            type: 'array', 
                            cellDates: true,        // Pr√©server les dates
                            cellNF: true,           // Pr√©server les formats de nombres
                            cellText: true,         // Optimiser pour le texte
                            codepage: 65001,        // UTF-8 codepage
                            WTF: true               // Activer le mode d√©bogage d√©taill√©
                        });
                        
                        // Afficher les noms des feuilles disponibles
                        debug(`Feuilles disponibles: ${workbook.SheetNames.join(', ')}`);
                        
                        // Prendre la premi√®re feuille
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];
                        
                        // Convertir en JSON avec options d'encodage optimis√©es
                        data = XLSX.utils.sheet_to_json(worksheet, {
                            raw: false,           // Garder le format texte
                            defval: "",           // Valeur par d√©faut pour cellules vides
                            header: "A",          // Utiliser les r√©f√©rences de colonnes comme en-t√™tes
                            range: worksheet['!ref'] // Utiliser toute la plage
                        });
                        
                        // Si aucun en-t√™te n'est trouv√©, utiliser la premi√®re ligne comme en-t√™tes
                        if (data.length > 0) {
                            const headers = data[0];
                            const rows = data.slice(1);
                            
                            data = rows.map(row => {
                                const newRow = {};
                                Object.keys(headers).forEach(key => {
                                    // Utiliser les valeurs de la premi√®re ligne comme noms de colonnes
                                    newRow[headers[key]] = row[key] || "";
                                });
                                return newRow;
                            });
                        }
                    }
                    
                    if (data && data.length > 0) {
                        debug(`${data.length} lignes charg√©es`);
                        debug(`Colonnes d√©tect√©es: ${Object.keys(data[0]).join(', ')}`);
                        
                        // Afficher les premi√®res lignes pour d√©bogage
                        debug(`Premi√®re ligne (avec encodage pr√©serv√©): ${JSON.stringify(data[0], null, 2)}`);
                        
                        // Pr√©parer les donn√©es dans le format attendu
                        prepareDataFromFile(data);
                    } else {
                        debug("Aucune donn√©e trouv√©e dans le fichier", true);
                    }
                } catch (error) {
                    debug(`Erreur lors du traitement du fichier: ${error.message}`, true);
                    console.error(error);
                }
            };
            
            reader.onerror = function() {
                debug("Erreur lors de la lecture du fichier", true);
            };
            
            if (file.name.endsWith('.csv')) {
                // Sp√©cifier explicitement UTF-8 pour le CSV
                reader.readAsText(file, "UTF-8");
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        function prepareDataFromFile(fileData) {
            try {
                debug("Pr√©paration des donn√©es pour visualisation...");
                
                // D√©terminer les noms des colonnes (plus robuste)
                const sample = fileData[0];
                
                // Fonctions am√©lior√©es pour d√©tecter les noms de colonnes
                function isIdColumn(key) {
                    if (!key) return false;
                    const k = String(key).toLowerCase().trim();
                    return k === 'id' || k.endsWith('_id') || k === 'identifiant' || k === 'numero';
                }
                
                function isNameColumn(key) {
                    if (!key) return false;
                    const k = String(key).toLowerCase().trim();
                    return k === 'name' || k === 'nom' || k === 'libelle' || k === 'label' || k === 'titre' || k === 'description';
                }
                
                function isParentIdColumn(key) {
                    if (!key) return false;
                    const k = String(key).toLowerCase().trim();
                    return k === 'parent_id' || k === 'parentid' || k === 'parent id' || k === 'id_parent' || 
                           k === 'idparent' || k === 'id parent' || k === 'parent' || k === 'pere' || k === 'racine';
                }
                
                let idColumn = Object.keys(sample).find(isIdColumn);
                let nameColumn = Object.keys(sample).find(isNameColumn);
                let parentIdColumn = Object.keys(sample).find(isParentIdColumn);
                
                // Si les colonnes ne sont pas trouv√©es, d√©tecter avec une approche plus flexible
                if (!idColumn) {
                    idColumn = Object.keys(sample).find(key => key && String(key).toLowerCase().includes('id') && !String(key).toLowerCase().includes('parent'));
                }
                if (!nameColumn) {
                    nameColumn = Object.keys(sample).find(key => key && (String(key).toLowerCase().includes('name') || 
                                                                 String(key).toLowerCase().includes('nom') || 
                                                                 String(key).toLowerCase().includes('title')));
                }
                if (!parentIdColumn) {
                    parentIdColumn = Object.keys(sample).find(key => key && String(key).toLowerCase().includes('parent'));
                }
                
                if (!idColumn || !nameColumn || !parentIdColumn) {
                    debug(`Colonnes requises non trouv√©es. Utilisez ID, Name et Parent_ID. Colonnes actuelles: ${Object.keys(sample).join(', ')}`, true);
                    return;
                }
                
                debug(`Utilisation des colonnes: ID=${idColumn}, Name=${nameColumn}, Parent_ID=${parentIdColumn}`);
                
                // Nettoyer les donn√©es avec pr√©servation am√©lior√©e des caract√®res sp√©ciaux
                const cleanData = fileData.map(row => {
                    // Traitement de l'ID
                    const rawId = row[idColumn];
                    const id = (typeof rawId === 'string') ? 
                        parseInt(rawId.trim(), 10) : (typeof rawId === 'number' ? rawId : NaN);
                    
                    if (isNaN(id)) {
                        debug(`Avertissement: ID invalide dans une ligne: ${rawId}`, true);
                        return null;
                    }
                    
                    // Traitement du nom (pr√©servation maximale des caract√®res sp√©ciaux)
                    let name = "";
                    if (row[nameColumn] !== undefined && row[nameColumn] !== null) {
                        name = String(row[nameColumn]);
                        // D√©tecter et traiter les probl√®mes d'encodage courants
                        name = name.replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec));
                        name = name.replace(/&#x([0-9A-Fa-f]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)));
                    }
                    
                    // Traitement du parent ID
                    const rawParentId = row[parentIdColumn];
                    let parentId = (typeof rawParentId === 'string') ? 
                        parseInt(rawParentId.trim(), 10) : (typeof rawParentId === 'number' ? rawParentId : 0);
                    
                    parentId = !isNaN(parentId) ? parentId : 0;
                    
                    return { id, name, parentId };
                }).filter(item => item !== null); // Filtrer les √©l√©ments invalides
                
                // Afficher des exemples de donn√©es pr√©par√©es
                if (cleanData.length > 0) {
                    debug(`Exemple de donn√©es pr√©par√©es (premi√®re ligne): ${JSON.stringify(cleanData[0])}`);
                    // V√©rifier si des caract√®res sp√©ciaux ont √©t√© pr√©serv√©s
                    const hasSpecialChars = cleanData.some(item => 
                        /[√©√®√™√´√†√¢√§√π√ª√º√≤√¥√∂√Ø√Æ√ß]|[\u{1F300}-\u{1F6FF}]/u.test(item.name));
                    if (hasSpecialChars) {
                        debug("‚úÖ Caract√®res sp√©ciaux et emojis d√©tect√©s et correctement pr√©serv√©s!");
                    }
                }
                
                // Traiter et afficher les donn√©es
                processLoadedData(cleanData);
                
            } catch (error) {
                debug(`Erreur lors de la pr√©paration des donn√©es: ${error.message}`, true);
                console.error(error);
            }
        }

        function useExampleData() {
            debug("Chargement des donn√©es d'exemple avec caract√®res sp√©ciaux et emojis...");
            
            const exampleData = [
                // Premier arbre avec caract√®res sp√©ciaux et emojis
                { ID: 1, Name: "Vitrage Bo√Æte T2 üè¢", Parent_ID: 0 },
                { ID: 2, Name: "Mat√©riels & √âquipements", Parent_ID: 1 },
                { ID: 3, Name: "Grue sur remorque (Kl√§ss)", Parent_ID: 2 },
                { ID: 4, Name: "Palonnier √† ventouse ‚ú®", Parent_ID: 2 },
                { ID: 5, Name: "Plaques de r√©partition üîß", Parent_ID: 2 },
                { ID: 6, Name: "Vitrages (R√âB√àR)", Parent_ID: 2 },
                { ID: 7, Name: "Nacelle araign√©e 27m üï∏Ô∏è", Parent_ID: 2 },
                { ID: 8, Name: "Sous-√©l√©ment 1-A", Parent_ID: 3 },
                { ID: 9, Name: "Sous-√©l√©ment 1-B", Parent_ID: 3 },
                { ID: 10, Name: "Chien üêï", Parent_ID: 4 },
                { ID: 11, Name: "Chat üêà", Parent_ID: 4 },
                { ID: 12, Name: "Sous-√©l√©ment 2-A", Parent_ID: 5 },
                { ID: 13, Name: "Sous-√©l√©ment 2-B", Parent_ID: 5 },
                { ID: 14, Name: "Sous-√©l√©ment 3-A", Parent_ID: 6 },
                { ID: 15, Name: "Sous-√©l√©ment 4-A", Parent_ID: 7 },
                { ID: 16, Name: "Sous-√©l√©ment 4-B", Parent_ID: 7 },